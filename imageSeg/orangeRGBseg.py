import cv2
import numpy as np
import math
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from sklearn import metrics
from enum import Enum

# Class for RGB segmentation for orange
class OrangeSegRGB:
    """
    An OpenCV pipeline generated by GRIP.
    """
    
    def __init__(self):
        """initializes all values to presets or None if need to be set
        """

        self.__rgb_threshold_red = [178.86690647482015, 255.0]
        self.__rgb_threshold_green = [0.0, 160.55555555555554]
        self.__rgb_threshold_blue = [0.0, 212.07070707070707]

        self.rgb_threshold_output = None


    def process(self, source0):
        """
        Runs the pipeline and sets all outputs to new values.
        """
        # Step RGB_Threshold0:
        self.__rgb_threshold_input = source0
        (self.rgb_threshold_output) = self.__rgb_threshold(self.__rgb_threshold_input, self.__rgb_threshold_red, self.__rgb_threshold_green, self.__rgb_threshold_blue)


    @staticmethod
    def __rgb_threshold(input, red, green, blue):
        """Segment an image based on color ranges.
        Args:
            input: A BGR numpy.ndarray.
            red: A list of two numbers the are the min and max red.
            green: A list of two numbers the are the min and max green.
            blue: A list of two numbers the are the min and max blue.
        Returns:
            A black and white numpy.ndarray.
        """
        #out = cv2.cvtColor(input, cv2.COLOR_BGR2RGB)
        return cv2.inRange(input, (red[0], green[0], blue[0]),  (red[1], green[1], blue[1]))


def findTPRandFPR(true, pred):
	numLabels = np.size(true)
	tp = 0.
	fp = 0.
	tn = 0.
	fn = 0.

	for i in range(numLabels):
		if true[i] == 1 and pred[i] == 1:
			tp += 1
		elif true[i] == 1 and pred[i] == 0:
			fn += 1
		elif true[i] == 0 and pred[i] == 1:
			fp += 1
		elif true[i] == 0 and pred[i] == 0:
			tn += 1

	tpr = tp / (tp + fn)
	fpr = fp / (fp + tn)

	return tpr, fpr


# Input image characteristics
imgRange = np.arange(1,518) # Will read in images 00496 through 00517
numImg = 517
imgSize = (1530, 2720, 3)

img = np.zeros(imgSize)
segImg = np.zeros((imgSize[0], imgSize[1]))


# Labels for images
# 0 - No orange, 1 - Orange
labels = np.zeros(numImg)
labels[0:7] = 1
labels[7:21] = 0
labels[21:34] = 1
labels[34:45] = 0
labels[45] = 1
labels[46] = 0
labels[47] = 1
labels[48:193] = 0
labels[193:208] = 1
labels[208:211] = 0
labels[211:230] = 1
labels[230:333] = 0
labels[333:345] = 1
labels[345:501] = 0
labels[501:512] = 1
labels[512:518] = 0


# Create RGB Segmenter object
seg = OrangeSegRGB()

# Thresholds
thres = np.arange(100,401,50)
orange = np.zeros((np.size(thres), numImg))


n = 0
for i in imgRange:
	# Read in images
	if i < 10:
        	img = mpimg.imread('AMountian_0002-0000' + str(i) + '.jpg')
	elif i < 100:
        	img = mpimg.imread('AMountian_0002-000' + str(i) + '.jpg')
	else:
        	img = mpimg.imread('AMountian_0002-00' + str(i) + '.jpg')

    	# Segment image
	seg.process(img)
	segImg = seg.rgb_threshold_output


   	# Determine number of orange pixels segmented
	orangePixNum = np.count_nonzero(segImg)

	# Run image through all thresholds
	t = 0
	for th in thres:
		if orangePixNum >= th:
			orange[t,n] = 1

		t += 1

	n += 1


#print(labels)
#print(orange)
#print('Incorrect Predictions:')
#print(np.where(orange != labels))
#print('')

# Show true labels vs predicted labels
#print('True labels:')
#print(labels)
#print('')
#print('Predicted labels:')
#print(orange)


# Calculate ROC
#fpr, tpr, thresholds = metrics.roc_curve(labels,orange)
tpr = np.zeros(np.size(thres))
fpr = np.zeros(np.size(thres))

for i in range(np.size(thres)):
	tpr[i],fpr[i] = findTPRandFPR(labels, orange[i])


#print('TPR:')
#print(tpr)
#print('')
#print('FPR:')
#print(fpr)

plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve')
plt.plot([0, 1], [0, 1], color='navy', linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver operating characteristic')
plt.legend(loc="lower right")
plt.show()
