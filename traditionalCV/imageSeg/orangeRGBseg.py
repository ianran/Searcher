import cv2
import numpy as np
import math
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import labelReader
import glob
from sklearn import metrics
from enum import Enum
from mpl_toolkits import mplot3d

# Class for RGB segmentation for orange
class OrangeSegRGB:
    """
    An OpenCV pipeline generated by GRIP.
    """
    
    def __init__(self):
        """initializes all values to presets or None if need to be set
        """

        self.__rgb_threshold_red = [178.86690647482015, 255.0]
        self.__rgb_threshold_green = [0.0, 160.55555555555554]
        self.__rgb_threshold_blue = [0.0, 212.07070707070707]

        self.rgb_threshold_output = None


    def process(self, source0):
        """
        Runs the pipeline and sets all outputs to new values.
        """
        # Step RGB_Threshold0:
        self.__rgb_threshold_input = source0
        (self.rgb_threshold_output) = self.__rgb_threshold(self.__rgb_threshold_input, self.__rgb_threshold_red, self.__rgb_threshold_green, self.__rgb_threshold_blue)


    @staticmethod
    def __rgb_threshold(input, red, green, blue):
        """Segment an image based on color ranges.
        Args:
            input: A BGR numpy.ndarray.
            red: A list of two numbers the are the min and max red.
            green: A list of two numbers the are the min and max green.
            blue: A list of two numbers the are the min and max blue.
        Returns:
            A black and white numpy.ndarray.
        """
        #out = cv2.cvtColor(input, cv2.COLOR_BGR2RGB)
        return cv2.inRange(input, (red[0], green[0], blue[0]),  (red[1], green[1], blue[1]))


def findTPRandFPR(true, pred, numThres):
	tpr = np.zeros(numThres)
	fpr = np.zeros(numThres)
	
	for i in range(numThres):
		tp = 0.
		fp = 0.
		tn = 0.
		fn = 0.

		for fName in pred.keys():

			if true.get(fName) == 'True' and pred.get(fName)[i] == True:
				tp += 1
			elif true.get(fName) == 'True' and pred.get(fName)[i] == False:
				fn += 1
			elif true.get(fName) == 'False' and pred.get(fName)[i] == True:
				fp += 1
			elif true.get(fName) == 'False' and pred.get(fName)[i] == False:
				tn += 1

		tpr[i] = tp / (tp + fn)
		fpr[i] = fp / (fp + tn)

	return tpr, fpr


labels = labelReader.readLabelsDict('labels.csv')
orangeDect = {}

# Input image characteristics
imgSize = (1530, 2720, 3)

img = np.zeros(imgSize)
segImg = np.zeros((imgSize[0], imgSize[1]))

# Create RGB Segmenter object
seg = OrangeSegRGB()

# Thresholds
thres = np.arange(0,5001,10)


# Read images one at a time and put them through color segmentation.
for fName in glob.glob('*.jpg'):

	orangeDect[fName] = []

	img = mpimg.imread(fName)

    	# Segment image
	seg.process(img)
	segImg = seg.rgb_threshold_output


   	# Determine number of orange pixels segmented
	orangePixNum = np.count_nonzero(segImg)

	# Run image through all thresholds
	t = 0
	for th in thres:
		if orangePixNum >= th:
			orangeDect[fName].append(True)
		else:
			orangeDect[fName].append(False)



# Calculate ROC
tpr,fpr = findTPRandFPR(labels, orangeDect, np.size(thres))


# Plot ROC curve
plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve')
plt.plot([0, 1], [0, 1], color='navy', linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver operating characteristic')
plt.legend(loc="lower right")



# Plot tpr vs fpr vs threshold
fig = plt.figure()
ax = fig.add_subplot(111, projection = '3d')

ax.scatter(tpr[1:21], fpr[1:21], thres[1:21], c='r', marker='o')
ax.set_xlabel('True Positive Rate')
ax.set_zlabel('False Positive Rate')
ax.set_zlabel('Threshold')
plt.show()
